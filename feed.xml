<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/dingyue772/gitBlog</id><title>RSS feed of dingyue772's gitBlog</title><updated>2024-04-06T11:55:13.832676+00:00</updated><link href="https://github.com/dingyue772/gitBlog"/><link href="https://raw.githubusercontent.com/dingyue772/gitBlog/main/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/dingyue772/gitBlog/issues/2</id><title>【代码随想录】回溯算法</title><updated>2024-04-06T11:55:13.990199+00:00</updated><content type="html"><![CDATA[<h2>理论基础</h2>
<p><strong>力扣题目分类展示</strong>
<img src="https://github.com/dingyue772/gitBlog/assets/90541495/07aa358a-4d9c-4858-8ade-9f8e02bd0657" alt="image" /></p>
<p><strong>回溯法理解</strong></p>
<blockquote>
<p>所有使用回溯法解决的问题都可以抽象成树形结构
在集合中递归查找子集：集合大小即树的宽度，递归的深度即树的深度</p>
</blockquote>
<p><strong>回溯法模板</strong>
回溯三部曲：<strong>函数返回值及参数——函数终止条件——搜索的遍历过程</strong></p>
<pre><code class="language-C++">void backtracking(参数){
  if (终止条件){
    存放结果;
    return;
  }
  
  for (选择: 本层集合中元素(树中节点孩子数量就是集合大小)){
    处理节点;
    backtracking(路径, 选择列表); // 递归过程
    回溯, 撤销处理结果;
  }
}
</code></pre>
<p><img src="https://github.com/dingyue772/gitBlog/assets/90541495/35094e9d-d9d6-4fb9-9231-d58d5ec79720" alt="image" /></p>
<h3>93. 复原IP地址</h3>
<p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接</a></p>
<pre><code class="language-txt">给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#x27;.&#x27; 分隔。
例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效的 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效的 IP 地址。
</code></pre>
<p><strong>难点</strong></p>
<ol>
<li>字符串处理，在原有字符串里加入'.'，<code>s.insert()</code>和<code>s.erase()</code>的使用</li>
<li>判断子串是否满足IP地址的要求，不能前导0&amp;范围在0~255
<strong>代码说明</strong>
函数定义</li>
</ol>
<pre><code class="language-C++">// 引入pointNum标识当前的逗点数量
void backtracking(string&amp; s, int startIndex, int pointNum)
</code></pre>
<p>终止条件</p>
<pre><code class="language-C++">if (pointNum == 3){
  if (isValid(s, startIndex, s.size()-1)) {
    result.push_back(s);
  }
  return;
}
</code></pre>
<p>单层递归</p>
<pre><code class="language-C++">for (int i=startIndex; i&lt;s.size(); i++) {
  if (isValid(s, startIndex, i)){
    s.insert(s.begin()+i+1, &#x27;.&#x27;);
    pointNum++;
    backtracking(s, i+2, pointNum);
    pointNum--;
    s.erase(s.begin()+i+1);
  }
  else break;
}
</code></pre>
<p>IP地址判断：使用字符串计算出对应的IP分量的值进行判断</p>
<pre><code class="language-C++">bool isValid(const string s, int start, int end)
</code></pre>
<h2>参考资料</h2>
<p><a href="https://programmercarl.com/">代码随想录</a></p>
]]></content><link href="https://github.com/dingyue772/gitBlog/issues/2"/><published>2024-04-06T11:54:51+00:00</published></entry><entry><id>https://github.com/dingyue772/gitBlog/issues/1</id><title>Github Issues博客之旅</title><updated>2024-04-06T11:55:14.062608+00:00</updated><content type="html"><![CDATA[<p><strong>感谢yihong老师开源的gitblog项目！</strong></p>
<h2>建立过程</h2>
<p>开始于看到朋友在github仓库里利用issues写博客<a href="https://github.com/KMnO4-zx/blog">不要葱姜蒜的blog仓库</a>，然后去google相关的教程，看到了大佬教程——<a href="https://zhuanlan.zhihu.com/p/400962805">使用Github Issues来写博客</a>，接着就看到<a href="https://github.com/yihong0618/gitblog">yihong老师的gitblog项目</a>了，真的有被震撼到。在看的过程中我心里想的是“所有你想做的事情，世界上都有人在做了，并且做得很好！”，接着就下定决心要把我的gitblog搞起来</p>
<h2>tips</h2>
<p>同样的gitblog工作流建立参考<a href="https://zhuanlan.zhihu.com/p/400962805">使用Github Issues来写博客</a>和<a href="https://github.com/yihong0618/gitblog/issues/177">这个博客开源了</a>
<strong>注意</strong></p>
<ol>
<li>yihong老师的workflow文件夹中有两个action，generate_site.yml是和github pages关联的，可以查看内容后进行相应的配置再使用</li>
<li>一定要注意打开repository的settings中的actions的读写权限！！！ （我在这里卡了很久很久</li>
</ol>
<h2>issues写博客的优势</h2>
<ol>
<li>提交issues自动更新仓库readme，并且根据label将issues展示在不同的二级标题下</li>
<li>backup文件夹自动将所有issues以.md文件的形式保存起来</li>
<li>生成了feed.xml供订阅、并方便查看</li>
</ol>
<p>ps：我用到的功能只是原gitblog项目的一部分，这里可以写的还有很多！</p>
]]></content><link href="https://github.com/dingyue772/gitBlog/issues/1"/><category term="工作流"/><published>2024-04-05T04:46:08+00:00</published></entry></feed>